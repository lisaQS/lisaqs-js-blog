# [手写源码系列](https://github.com/lisaQS/lisaqs-js-blog/issues/3)

### 一、JS基础

**1. 手写Object.create**
```js
// 将传入的对象作为原型
function create(obj) {
    function F() {}
    F.prototype = obj;
    return new F();
}
```

**2. 手写new操作符**
```js
/**
**先创建一个对象,将对象的原型设置为函数的prototype对象
**让函数的this指向这个对象，执行构造函数的代码，为这个新对象添加属性
**判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
**/
function myNew(fn, ...args) {
    let obj = Object.create(fn.prototype);
	let res = fn.call(obj, ...args);
	if (res && (typeof res === 'object' || typeof res === 'function')) {
		return res;
	}
	return obj;
}

```

PS: 你能说出object.create和new的不同之处吗？

**3. 手写instanceof操作符**
```js
function myInstanceof(left, right) {
    let proto = Object.getPrototypeOf(left), prototype = right.prototype;
    while (true) {
        if (!proto) return false;
        if (proto === prototype) return true;
        proto = Object.getPrototypeof(proto);
    }
}
```
**4. 用setTimeout模拟实现setInterval(带清除定时器的版本)**

```js
function myInterval(fn, delay = 500) {
    let timer = null;
    function interval() {
        fn();
        timer = setTimerout(interval, delay);
    }
    interval();
    return {
        cancel: () => {
            clearTimeout(timer)
        }
    }
}
```
PS: setInterval() 和 setTimeout() 有什么区别？

**5. call bind apply 的实现**

```js
Function.prototype.call = function(context = window, ...args) {
    let fn = Symbol();
    context[fn] = this;
    return context[fn](...args)
}

Function.prototype.apply = function(context = window, args) {
    let fn = Symbol();
    context[fn] = this;
    return context[fn](...args);
}

/*
** bind函数除了能修改this指向之外，他返回的是一个函数
**这个函数是可以当作构造函数，用过new操作符使用的
*/
Function.prototype.bind = function(context = window) {
    let self = this;
    let outerArgs = Array.prototype.slice.call(arguments, 1);

    let fNOP = function() {};
    let fBind = function() {
        let bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, bindArgs.concat(outerArgs))
    }
    fNOP.prototype = this.prototype;
    fBind.protoype = new fNOP();
    return fBind;
}
```
PS: 你知道这三者的区别吗？ arguments是什么？

**6. Promise系列的手写**
```js
const PENDING = 'pending';
const RESOLVED = 'fulfilled';
const REJECTED = 'rejected';

class Promise {
    constructor(fn) {
        this.state = PENDING;
        this.successCBs = [];
        this.failCSs = [];

        let resolve = (val) => {
            if (this.state !== PENDING) {
                return ;
            }
            this.state = RESOLVED;
            setTimeout(() => {
                this.successCBs.forEach(item => {
                    item.call(this, val)
                })
            });
        }

        let reject = (err) => {
            if (this.state !== PENDING) {
                return ;
            }
            this.state = REJECTED;
            setTimeout(() => {
                this.failCBs.forEach((item) => {
                    item.call(this, err);
                })
            })
        }

        try {
            fn(resolve, reject);
        } catch(err) {
            reject(err);
        }
    }
    then(resolveCB, rejectCB) {
        //验证是否是函数，否则值透传
        resolveCB = typeof resolveCB === 'function' ? resolveCB : (v) => v;
        rejectCB = typeof rejectCB === 'function' ? rejectCB : (err) => {
            throw err;
        }
        //为了保持链式调用，必须返回Promise
        return new Promise((resolve, reject) => {
            this.successCBs.push((val) => {
                try {
                    let x = resolveCB(val);
                    //如果结果是普通值，那么就resolve给下一个then链式调用;
                    //如果是一个Promise对象，需要调用then方法，将resolve和reject传进去，
                    //等到x内部的异步执行完毕之后，自动执行传入的resolve,用来控制链式调用的顺序;
                    x instanceof Promise ? x.then(resolve, reject) : resolve(x);
                } catch(err) {
                    reject(err);
                } 
            })
            this.failCBs.push((val) => {
                try {
                    let x = rejectCB(val);
                    x instanceof Promise ? x.then(resolve, reject) : reject(x);
                }
            })
        }) 
        static all(promiseArr) {
            let result = [];
            let count = 0;
            return new Promise((resolve, reject) => {
                for (let i = 0; i < promiseArr.length; i++) {
                    Promise.resolve(promiseArr[i]).then((res) => {
                        result[i] = res;
                        count++;
                        if (count === promiseArr.length) {
                            resolve(result);
                        }
                    }, (err) => {
                        reject(err)
                    })
                }
            })
        }
        static race(promiseArr) {
            return new Promise((resolve, reject) => {
                for (let i = 0; i < promiseArr.length; i++) {
                    Promise.resolve(promiseArr[i]).then((res) => {
                        resolve(res)
                    }, (err) => {
                        reject(err)
                    })
                }
            })
        }
    }
}

```

PS: 如何取消promise

**7.手写防抖、节流函数**
```js
function debounce(fn, delay = 500) {
    let timer ;
    return function() {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(fn, delay);
    }
}

function throttle(fn, delay = 500) {
    let timer;
    return function() {
        if (timer) return ;
        timer = setTimeout(fn, delay);
    }
}

```

**8.函数柯里化的实现**
```js
function curry(fn, ...args) {
    const length = fn.length;
    let allArgs = [...args];
    const res = (...newArgs) => {
        allArgs = [...allArgs, ...newArgs];
        if (allArgs.length === length) {
            return fn(...allArgs);
        } else {
            return res;
        }
    }
    return res;
}
```

**9. 用Promise封装AJAX请求**
```js
function myAjax(url) {
    let promise = new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(xhr.responseText)
                } else {
                    reject(new Error(xhr.responseText));
                }
            }
        }
        xhr.send();
    })
}
``` 

**10.深拷贝的实现**
```js
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function deepClone(obj, map = new WeakMap()) {
    if (!isObject(obj)) return obj;
    if (map.has(obj)) return map.get(obj);
    let target = Array.isArray(obj) ? [] : {};
    map.set(obj, target);
    Reflect.ownKeys(obj).forEach(key => {
        let value = obj[key];
        if (isObject(value)) {
            target[key] = deepClone(value, map)
        } else {
            target[key] = value;
        }
    })
}
```

### 二、JS数据处理

